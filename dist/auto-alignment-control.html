<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Layout Alignment</title>
    <style>
        :root{
            --cell-size: 15px;
        }
        body {
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, "system-ui", "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, SFProLocalRange;
            margin: 0;
            background-color: var(--figma-color-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Ensure body takes full height for centering */
            text-align: center;
            color: var(--figma-color-text);
            font-size: 11px;
        }
        #alignment-grid {
            display: grid; /* Will be controlled by JS, initially might be none */
            grid-template-columns: repeat(3, 15px);
            grid-template-rows: repeat(3, 15px);
            gap: 5px;
            padding: 5px;
            background-color: var(--figma-color-bg-secondary);
            align-items: center;
            border-radius: 5px;
            justify-items: center;
        }
        #alignment-grid:focus {
            outline: 2px solid var(--figma-color-bg-brand);
            outline-offset: 1px;
        }
        .grid-cell {
            width: var(--cell-size);
            height: var(--cell-size);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: default;
            border-radius: 3px;
            /* content: ''; */ /* Removed as it's not standard for a div */
            background-color: var(--figma-color-icon-tertiary);
            width: 3px;
            height: 3px;
            /* display: block; */ /* Flex properties handle this better */
            position: relative; /* For positioning distribution bars */
        }
        .grid-cell.selected {
            width: 100%;
            height: 100%;
            background-color: var(--figma-color-bg-brand);
        }
        .grid-cell:focus {
            outline: 2px solid var(--figma-color-bg-brand);
            outline-offset: 1px;
        }
        .distribution-bar {
            position: absolute;
            background-color: var(--figma-color-bg-brand); /* A slightly different blue or use brand */
            border-radius: 5px;
        }
        #instructions {
            margin-top: 50px;
            color: var(--figma-color-text-secondary);
            display: flex;
            gap: 5px;
        }
        .key {
            display: inline-block;
            border: 1px solid var(--figma-color-text-secondary);
            padding: 3px;
            border-radius: 5px;
        }

        
    </style>
</head>
<body>
    <div id="message-container" style="display: none;">
        Select an auto layout frame
    </div>
    <div class="grid-container" style="display: flex; flex-direction: column; align-items: center;"> <!-- Initially show grid, will be controlled by JS -->
        <div id="alignment-grid" tabindex="0">
            <!-- Cells will be generated by script -->
        </div>
        <div id="instructions">
            <span class="key"><—</span>
            <span class="key">—></span>
            <span class="key">SPACE</span>
        </div>
    </div>
    <script>
        // UI logic will go here
        const alignmentGrid = document.getElementById('alignment-grid');
        const gridContainer = document.querySelector('.grid-container');
        const messageContainer = document.getElementById('message-container');

        // UI State
        let selectedIndex = 4; // 0-8, 4 is center
        let isDistributeModeVisual = false;
        let currentLayoutMode = 'HORIZONTAL'; // 'HORIZONTAL' or 'VERTICAL', default
        let currentFigmaAlignment = { primary: 'CENTER', counter: 'CENTER' };


        // Create 9 grid cells
        for (let i = 0; i < 9; i++) {
            const cell = document.createElement('div');
            cell.classList.add('grid-cell');
            cell.dataset.index = i;
            alignmentGrid.appendChild(cell);
        }

        function updateSelectedCell() {
            const cells = alignmentGrid.querySelectorAll('.grid-cell');
            cells.forEach((cell, index) => {
                if (index === selectedIndex) {
                    cell.classList.add('selected');
                } else {
                    cell.classList.remove('selected');
                }
                // If not in distribution mode, ensure any lingering inline styles from it are cleared.
                // This allows the CSS classes (.grid-cell, .grid-cell.selected) to take full effect.
                if (!isDistributeModeVisual) {
                    cell.style.backgroundColor = '';
                    cell.style.width = '';
                    cell.style.height = '';
                }
            });
        }
        
        // updateSelectedCell(); // Initial selection will be set by the first message from the plugin

        // Focus the grid on load
        // alignmentGrid.focus(); // Will be focused when valid selection is made

        // Focus the grid when the window is clicked
        window.addEventListener('click', () => {
            if (gridContainer.style.display !== 'none') { // Only focus if grid is visible
                alignmentGrid.focus();
            }
        });

        function updateDistributionVisuals() {
            const cells = alignmentGrid.querySelectorAll('.grid-cell');
            
            // Clear existing bars and reset any inline styles from previous distribution rendering
            cells.forEach(cell => {
                const existingBar = cell.querySelector('.distribution-bar');
                if (existingBar) {
                    existingBar.remove();
                }
                // Reset inline styles so CSS classes can take over if not in distribution mode,
                // or so this function can cleanly apply new styles if in distribution mode.
                cell.style.backgroundColor = '';
                cell.style.width = '';
                cell.style.height = '';
            });

            if (!isDistributeModeVisual) {
                return; // Nothing more to do if not in distribution mode
            }

            const activeRow = Math.floor(selectedIndex / 3);
            const activeCol = selectedIndex % 3;

            const cellsInDistributionIndices = [];
            if (currentLayoutMode === 'HORIZONTAL') {
                for (let i = 0; i < 3; i++) cellsInDistributionIndices.push(activeRow * 3 + i);
            } else { // VERTICAL
                for (let i = 0; i < 3; i++) cellsInDistributionIndices.push(i * 3 + activeCol);
            }

            cellsInDistributionIndices.forEach(cellIdx => {
                const cell = cells[cellIdx];
                
                // Override default/selected appearance to show bar
                cell.classList.remove('selected'); // Remove .selected class if present
                cell.style.backgroundColor = 'var(--figma-color-bg-secondary)'; // Match grid background (hides dot)
                cell.style.width = 'var(--cell-size)'; // Ensure cell is full size for bar
                cell.style.height = 'var(--cell-size)';

                const bar = document.createElement('div');
                bar.classList.add('distribution-bar');

                if (currentLayoutMode === 'HORIZONTAL') {
                    bar.style.width = '4px';
                    bar.style.height = '100%';
                    bar.style.left = '50%';
                    bar.style.transform = 'translateX(-50%)';
                } else { // VERTICAL
                    bar.style.height = '4px';
                    bar.style.width = '100%';
                    bar.style.top = '50%';
                    bar.style.transform = 'translateY(-50%)';
                }
                cell.appendChild(bar);
            });
        }


        // Keyboard navigation
        alignmentGrid.onkeydown = (event) => {
            let newIndex = selectedIndex;
            const currentRow = Math.floor(selectedIndex / 3);
            const currentCol = selectedIndex % 3;
            let shouldSendAlignment = false;

            if (event.code === 'Space') {
                event.preventDefault();
                parent.postMessage({ pluginMessage: { type: 'toggle-distribution' } }, '*');
                return; // State will be updated by message from plugin
            }

            if (isDistributeModeVisual) {
                if (currentLayoutMode === 'HORIZONTAL') { // Distribute horizontally, arrows move counter (vertical)
                    switch (event.key) {
                        case 'ArrowUp':
                            if (currentRow > 0) newIndex -= 3;
                            shouldSendAlignment = true;
                            break;
                        case 'ArrowDown':
                            if (currentRow < 2) newIndex += 3;
                            shouldSendAlignment = true;
                            break;
                        case 'ArrowLeft': // No visual change in primary axis, but still send alignment
                        case 'ArrowRight':
                            shouldSendAlignment = true;
                            break;
                    }
                } else { // Distribute vertically, arrows move counter (horizontal)
                    switch (event.key) {
                        case 'ArrowLeft':
                            if (currentCol > 0) newIndex -= 1;
                            shouldSendAlignment = true;
                            break;
                        case 'ArrowRight':
                            if (currentCol < 2) newIndex += 1;
                            shouldSendAlignment = true;
                            break;
                        case 'ArrowUp': // No visual change in primary axis, but still send alignment
                        case 'ArrowDown':
                            shouldSendAlignment = true;
                            break;
                    }
                }
            } else { // Default (non-distribute) mode
                switch (event.key) {
                    case 'ArrowUp':
                        if (currentRow > 0) newIndex -= 3;
                        shouldSendAlignment = true;
                        break;
                    case 'ArrowDown':
                        if (currentRow < 2) newIndex += 3;
                        shouldSendAlignment = true;
                        break;
                    case 'ArrowLeft':
                        if (currentCol > 0) newIndex -= 1;
                        shouldSendAlignment = true;
                        break;
                    case 'ArrowRight':
                        if (currentCol < 2) newIndex += 1;
                        shouldSendAlignment = true;
                        break;
                }
            }
            
            if (event.key.startsWith('Arrow')) event.preventDefault();

            switch (event.key) {
                // Arrow cases handled above based on mode
                case 'Escape':
                case 'Enter': // Add Enter key to close dialog
                    parent.postMessage({ pluginMessage: { type: 'close-plugin' } }, '*');
                    event.preventDefault();
                    break;
                // s, t, r, 1, 0 for stroke commands - keep as is
                case 's': 
                    break;
                case 't': 
                    break;
                case 'r': 
                    break;
                case '1':
                    if (event.altKey && event.shiftKey) { 
                        parent.postMessage({ pluginMessage: { type: 'set-stroke', value: 1 } }, '*');
                        event.preventDefault();
                    }
                    break;
                case '0':
                     if (event.altKey && event.shiftKey) { 
                        parent.postMessage({ pluginMessage: { type: 'set-stroke', value: 0 } }, '*');
                        event.preventDefault();
                    }
                    break;
                default:
                     // If it's not an arrow key or other handled key, do nothing for alignment
                    if (!event.key.startsWith('Arrow')) return;
            }

            if (shouldSendAlignment && !event.altKey && event.key.startsWith('Arrow')) { 
                selectedIndex = newIndex;
                // updateSelectedCell(); // This will be handled by the response from the plugin
                parent.postMessage({ pluginMessage: { type: 'set-alignment', index: selectedIndex } }, '*');
            }
        };
        
        // Mapping from Figma alignment properties back to UI index (mirror from code.ts for UI logic)
        const figmaAlignmentMapToIndex = {
            'MINMIN': 0, 'CENTERMIN': 1, 'MAXMIN': 2,
            'MINCENTER': 3, 'CENTERCENTER': 4, 'MAXCENTER': 5,
            'MINMAX': 6, 'CENTERMAX': 7, 'MAXMAX': 8
        };

        function getIndexFromFigmaAlign(primary, counter) {
            const key = (primary || '').replace('SPACE_BETWEEN', 'CENTER') + (counter || ''); // Treat SPACE_BETWEEN as CENTER for primary for index mapping
            return figmaAlignmentMapToIndex[key] !== undefined ? figmaAlignmentMapToIndex[key] : 4; // Default to center
        }


        // Listen for messages from the plugin code
        window.onmessage = (event) => {
            const message = event.data.pluginMessage;
            if (!message) return;

            if (message.type === 'update-plugin-state') {
                isDistributeModeVisual = message.isDistributeActiveInFigma;
                currentLayoutMode = message.layoutMode || 'HORIZONTAL'; // Default if null
                currentFigmaAlignment.primary = message.currentFigmaPrimaryAlign;
                currentFigmaAlignment.counter = message.currentFigmaCounterAlign;

                if (message.hasValidSelection) {
                    gridContainer.style.display = 'flex';
                    messageContainer.style.display = 'none';
                    alignmentGrid.focus();

                    if (isDistributeModeVisual) {
                        // Determine selectedIndex based on counter-axis alignment
                        if (currentLayoutMode === 'HORIZONTAL') { // Vertical counter
                            if (currentFigmaAlignment.counter === 'MIN') selectedIndex = 1; // Top-Center like
                            else if (currentFigmaAlignment.counter === 'MAX') selectedIndex = 7; // Bottom-Center like
                            else selectedIndex = 4; // Middle-Center
                        } else { // Vertical layout, Horizontal counter
                            if (currentFigmaAlignment.counter === 'MIN') selectedIndex = 3; // Middle-Left like
                            else if (currentFigmaAlignment.counter === 'MAX') selectedIndex = 5; // Middle-Right like
                            else selectedIndex = 4; // Middle-Center
                        }
                    } else {
                        selectedIndex = getIndexFromFigmaAlign(currentFigmaAlignment.primary, currentFigmaAlignment.counter);
                    }
                } else {
                    gridContainer.style.display = 'none';
                    messageContainer.style.display = 'block';
                    alignmentGrid.blur();
                }
                updateSelectedCell();
                updateDistributionVisuals();
            }
            // Keep 'set-initial-alignment' for backward compatibility or remove if not used by plugin anymore
            // else if (message.type === 'set-initial-alignment') { ... }
        };

        // Request initial state from the plugin
        parent.postMessage({ pluginMessage: { type: 'get-initial-visibility' } }, '*'); // This type is handled by plugin to send full state

    </script>
</body>
</html>
